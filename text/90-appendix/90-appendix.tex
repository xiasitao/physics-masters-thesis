\renewcommand{\imagepath}{../90-appendix/img}

\appendix
\chapter{The Jones and Azimuth-Ellipticity Polarization Bases}\label{ch:pypol_trafos}

Polarization is commonly represented in the Jones basis, the Mueller basis, or in the azimuth-ellipticity basis of a Poincaré sphere. For reference, transformations between the Jones and the azimuth-ellipticity basis are outlined here, as they were used for polarization characterizations in chapter~\ref{ch:projected_implementation}. This appendix chapter follows~\cite{trager_springer_2012}, but with a different definition of right- and left-handedness.

\section*{Transformations}
In the Jones basis, polarization is denoted using two basis vectors, say $\{\KetText{H}, \KetText{V}\}$ (horizontal and vertical). Up to a global phase, each polarization vector $\vec J$ can be represented using the three real valued parameters $h > 0$, $v > 0$, $\phi$:\footnote[1]{The sign of $\phi$ was chosen such that right-handed circular polarization is represented as $\frac{1}{\sqrt{2}}\begin{pmatrix}1 \\ -i \end{pmatrix}$ in the Jones basis, as $V > 0$ in the Mueller basis, and as $\epsilon  = \SI{45}{\degree}$ in the azimuth-ellipticity basis.}
\begin{align}
    \vec J = \begin{pmatrix}h \\ v \exp(-i \phi)\end{pmatrix}
\end{align}

\paragraph*{Jones to Azimuth-Ellipticity}
In the Mueller basis, a given Jones polarization vector with $h$, $v$, and $\phi$ is represented as a stokes vector:
\begin{align}
    \vec S = \begin{pmatrix}
        I \\ Q \\ U \\ V
    \end{pmatrix} = 
    \begin{pmatrix}
      h^2 + v^2\\
      h^2 - v^2\\
      2hv \cos \phi\\
      2hv \sin \phi  
    \end{pmatrix}
\end{align}

In the azimuth-ellipticity basis of the Poincaré sphere, this state is expressed as
\begin{align}
    \begin{pmatrix}\alpha \\ \epsilon \end{pmatrix} =
    \begin{pmatrix}
        \frac{1}{2} \arctan \frac{2hv \cos \phi}{h^2 - v^2} + \Omega_{h, v}\\
        \frac{1}{2} \arcsin \frac{2hv\sin\phi}{h^2 + v^2}
    \end{pmatrix}
    ,
\end{align}
with $\Omega_{h > v} = 0$ and $\Omega_{h \leq v} = \frac{\pi}{2}$.

\paragraph*{Azimuth-Ellipticity to Jones}
For a given azimuth $\alpha$ and ellipticity $\epsilon$, the Stokes vector can be determined up to its first component $I$:
\begin{align}
    \vec S = I \cdot 
    \begin{pmatrix}
        1 \\
        \cos (2\alpha) \cos(2\epsilon) \\
        \sin (2\alpha) \cos(2\epsilon) \\
        \sin(2\epsilon) \\
    \end{pmatrix}.
\end{align}

For $I = 1$, one can conclude the Jones vector parameters $h$, $v$, and $\phi$ from this vector.
$V / U$ gives $\tan \phi = \frac{\tan(2\epsilon)}{\sin(2\alpha)}$, so
\begin{align}
    \phi = \arctan \frac{\tan(2\epsilon)}{\sin(2\alpha)},
\end{align}
with $\phi = \pm \frac{\pi}{2}$ for $\epsilon = \pm \frac{\pi}{4}$, and $\phi = 0$ for $\alpha  = 0$, and $\phi = \pm\pi$ for $\alpha = \pm\frac{\pi}{2}$.\todo{improve presentation of special cases}

$I + Q$ yields $ 2 h^2 = 1 + \cos(2\alpha) \cos(2\epsilon)$, so:
\begin{align}
    h = \sqrt{\frac{1 + \cos(2\alpha) \cos(2\epsilon)}{2}}
\end{align}

Analogously, $I - Q$ yields $ 2 v^2 = 1 - \cos(2\alpha) \cos(2\epsilon)$, so:
\begin{align}
    v = \sqrt{\frac{1 - \cos(2\alpha) \cos(2\epsilon)}{2}}
\end{align}


\section*{Using py-pol for Transforming from the Azimuth-Ellipticity Basis}
Using the Python library py-pol~\cite{noauthor_python_nodate} polarization vectors can be transformed from the azimuth-ellipticity basis to the Jones basis with
\begin{lstlisting}[language=Python]
def azimuth_ellipticity_to_jones(alpha, epsilon):
    polarisation = pypol.jones_vector.Jones_vector()
    polarisation.general_azimuth_ellipticity(alpha, epsilon)
    polarisation = polarisation.remove_global_phase()
    h, v = polarisation.parameters.components()
    v = v.conjugate()
    return h, v
\end{lstlisting}

Note that py-pol, as does~\cite{trager_springer_2012}, defines $\KetText{R} = \frac{1}{\sqrt{2}}(\KetText{H}+i\KetText{V})$ and $\KetText{L} = \frac{1}{\sqrt{2}}(\KetText{H}-i\KetText{V})$, which is why the $v$ components is conjugated.




\chapter{Coil Simulation Library}\label{ch:coil_simulation_library}
\section*{Outline of the implementation}
The coil simulation library features three base classes:
\begin{itemize}
    \item \texttt{CoilArrangement}, \textit{abstract}: This class models an arrangement of sets of coils with a common axis, symmetrical on the $xz$ plane. In order to model a coil arrangement, this class needs to be subclassed, with the subclass implementing the method \texttt{\_compile\_single\_stack}. A \texttt{CoilArrangement} is parameterized by
    \begin{itemize}
        \item the \texttt{name} of the arrangement,
        \item the \texttt{radius} of a coil (only for reference for the subclasses),
        \item the \texttt{current}, which is either a constant value or a function \texttt{current(coil\_index, row, column)} assigning different currents to each coil and windings by their on- (\texttt{row}) and cross-axis (\texttt{column}) index,
        \item the dimension \texttt{wire\_spacing} of the wire,
        \item the \texttt{on\_axis\_coil\_distance}, and
        \item whether the arrangement is operated in \texttt{gradient} mode.
    \end{itemize}
    \item \texttt{FieldMap}: This class provides maps of the field generated by a \texttt{CoilArrangement} and can plot the field along slices through the field maps and 3D plots of them.
    \item \texttt{CurvatureAnalyzer}: This class calculates trap frequencies and gradients of the field of an arrangement or pre-calculated fields.
\end{itemize}

The following coil geometries were implemented by subclassing \texttt{CoilArrangement}:
\begin{itemize}
    \item \texttt{ConeShapedCoilArrangement}: An cone shaped arrangement with increasing radius of the winding layers along the coil axis. Parameterized by \texttt{windings\_axis} along the arrangement axis ($y$), \texttt{windings\_cross\_axis}, and the opening angle \texttt{cone\_angle} of the cone (relating the on-axis position of a winding layer and its radius).
    \item \texttt{StackShapedCoilArrangement}: A \texttt{ConeShapedCoilArrangement} with \texttt{cone\_angle} = \SI[]{0}{\degree}.
    \item \texttt{LithiumLayoutShapedCoilArrangement}: A coil arrangement as suggested in~\cite{gantner_magnetic_2012}.
    \item \texttt{FourPancakeArrangement}: A coil arrangement of two equally sized stack shaped coils with a center-of-mass distance \texttt{coil\_width} for each other on each side of the arrangement (written by the student research assistant Jan Wozniak).
    \item \texttt{FourPancakeArrangementWithJumpingCoils}: Arrangement of four coils with additional jumping coils (written by the student research assistant Jan Wozniak).
\end{itemize}


\section*{Usage Examples}
The usage of the \textit{coil simulation library} is exemplarily shown with the following examples of a \texttt{ConeShapedArrangement}.

\subsection*{Instantiation}
\begin{lstlisting}[language=Python]
import coil_simulation_lib as csl
COIL_PROPERTIES = {
    'windings_axis': 6,
    'windings_cross_axis': 5,
    'cone_angle': np.arctan(1),
    'current': 400,
    'gradient': True,
    'radius': 83e-3,
    'wire_spacing': 5.3e-3,
    'on_axis_coil_distance': 85.5e-3,
    'non_conducting_cross_section_area': (1.5e-3)**2*np.pi + 4 * (5e-3 * 0.15e-3)
}
arrangement = csl.ConeShapedCoilArrangement(**COIL_PROPERTIES)
\end{lstlisting}

\subsection*{Visualization}
\begin{lstlisting}[language=Python]
arrangement.plot_arrangement_schematic(figsize=(9, 7), filename='schematic.pgf')
arrangement.display_in_3D(figsize=(9, 9), filename='3d.pgf')
\end{lstlisting}

\subsection*{Field Mapping}
\begin{lstlisting}[language=Python]
field_map_xy = csl.FieldMap(arrangement, 'xy', steps=100)
field_map_xy.plot_map()  # color map
field_map_xy.plot_landscape()  # 3D visualization
field_map_xy.plot_slices()  # field along axes
\end{lstlisting}

\subsection*{Field Strength, Gradient, and Curvature}
\begin{lstlisting}[language=Python]
curvature_analyzer = csl.CurvatureAnalyzer().from_arrangement(arrangement=arrangement, steps=100)
x_freq_in_Hz = curvature_analyzer.get_trap_frequency_on_axis("x")
x_gradient_in_G = curvature_analyzer.get_gradient_on_axis("x")*1e2
field_at_center_in_G =arrangement.field_at_center() * 1e4
\end{lstlisting}

\subsection*{Coil Properties}\todo[]{shorten or leave out}
\begin{lstlisting}[language=Python]
f'wire length: l = {arrangement.get_total_coil_length()/2:.2f} m'
f'resistance: R = {arrangement.get_single_coil_resistance()*1000:.2f} mOhm'
f'single winding pair + supply line resistance: R ~ {arrangement.get_single_coil_resistance(supply_line_length=3.1, coil_length_factor=1/3)*1000:.2f} mOhm'
f'inductance (single): L = {arrangement.estimate_single_coil_self_inductance()*1000:.2f} mH'
f'L/R time (single): L/R = {arrangement.get_single_coil_L_over_R_time()*1000:.2f} ms'
f'inductance (all): L = {arrangement.estimate_all_coils_self_inductance()*1000:.2f} mH'
f'L/R time (all): L/R = {arrangement.get_all_coils_L_over_R_time()*1000:.2f} ms'
f'magnetic dipole moment: m = {arrangement.get_magnetic_dipole_moment():.2f} Am^2'
f'magnetic dipole moment (single coil): m = {arrangement.get_magnetic_dipole_moment(coil_index=0):.2f} Am^2'
f'outward force: {arrangement.get_total_outward_force_on_single_coil()}'
\end{lstlisting}

\section*{Implementing New Coil Geometries}
In order to implement new coil geometries, a subclass of \texttt{CoilArrangement} implementing the \texttt{\_compile\_single\_stack} method must be written.

\texttt{\_compile\_single\_stack} layouts the geometry of the coil by configuring each winding of the coil as a \textit{magpylib}~\cite{noauthor_magpylibmagpylib_nodate} current loop and placing it in its position. It takes the \texttt{coil\_index} $\in \{-1, 1\}$ as an argument, indicating whether the left or the right coil should be laid out.

Conceptually, the implementation should iterate over all on-axis and cross-axis windings, adding a \textit{magpylib} current loop to a collection for each winding, and return the collection. The geometry is implemented by setting the position and radius of each winding as desired.
\begin{lstlisting}
collection = mpl.Collection()
current_factor = 1 if coil_index == 0 else -1  # opposite polarity on both sides
for row in range(self.windings_axis):
        on_axis_offset = (row - self.windings_axis/2 + 0.5) * winding_spacing
        for column in range(self.windings_cross_axis):
            radial_offset = np.tan(self.cone_angle)*on_axis_offset + (column - self.windings_cross_axis/2 + 0.5) * winding_spacing
            current = self.get_current(coil_index=coil_index, row=row, column=column)*current_factor
            loop = mpl.current.Loop(current=current, diameter=2*radius+2*radial_offset, position=(0, 0, on_axis_offset)
            collection.add(loop)
return collection
\end{lstlisting}
The \texttt{current\_factor} ensures that the fields actually have same polarity in homogeneous field mode. The \texttt{self.gradient} property doesn't need to be considered here. The call to \texttt{self.get\_current} retrieves the current, which can be set independently each coil and each winding.



\chapter{Rules of Thumb for Magnetic Fields and Gradients}
The following rules of thumb are useful for calculating the magnitude of homogeneous fields and gradients for coils in Helmholtz configuration, meaning that the distance of the coils equals their radius.

\section*{Homogeneous Fields}
The field in \href{https://www.youtube.com/watch?v=_3_JVVs2Kls}{Gauss} at the center of a Helmholtz configuration of coils of radius $r$, distance $r$, operated at current $I$ can be estimated as
\begin{align}\label{eq:rot_field}
    B(r, I) \approx \left. \frac{I}{\SI{1}{\ampere}} \middle/ \frac{r}{\SI{1}{\centi\meter}} ~ \cdot ~\SI{1}{\gauss}\right. .
\end{align}
This means that, roughly speaking, coils in  Helmholtz configuration generate a field of
\begin{align}\nonumber
    \SI{1}{\gauss} ~~ \text{per} ~~ \frac{\si{\ampere} ~~ \text{of current}}{\si{\centi\meter} ~~ \text{of radius}}~.
\end{align}

Figure~\ref{fig:rot_field} compares this rule of thumb to exact simulations with the \textit{coil simulation library} (see~\ref{ch:simulation} and~\ref{ch:coil_simulation_library}). The rule of thumb overestimates the field by about \SI{10}{\percent}.

\begin{figure}
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_field/rule_of_thumb_field_radius.pgf}}
        \end{pgfpicture}
        \caption{Dependency on the radius, with the coil distance fixed to the radius}
        \label{fig:rot_field_radius}
    \end{subfigure} 
    \hspace{0.03\textwidth}
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_field/rule_of_thumb_field_current.pgf}}
        \end{pgfpicture}
        \caption{Dependency on the current}
        \label{fig:rot_field_current}
    \end{subfigure} 

    \begin{subfigure}{\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_field/rule_of_thumb_field_3d.pgf}}
        \end{pgfpicture}
        \caption{Field as a function of radius and current: Exact fields are displayed in red, the rule-of-thumb approximation in gray above.}
        \label{fig:rot_field_3d}
    \end{subfigure}
    \caption{Fields in the center of a Helmholtz arrangement of coils for different radii and currents, comparing the rule of thumb \eqref{eq:rot_field} with simulated values. Parameters: $I = \SI{100}{\ampere}, r = \SI{10}{\centi\meter}, N_\text{windings} = 1$}
    \label{fig:rot_field}
\end{figure}


\section*{Gradient Fields}
A similar rule of thumb can be formulated for the gradient around the center between coils in the same configuration, meaning the distance of the coils equals their radius, along the coil axis:
\begin{align}\label{eq:rot_gradient}
    \pdv{B(r, I)}{x_\text{on-axis}} \approx \left. \frac{I}{\SI{1}{\ampere}} \middle/ \left(\frac{r}{\SI{1}{\centi\meter}}\right)^2 ~\cdot~ \SI{1}{\gauss\per\centi\meter} \right.
\end{align}

Figure~\ref{fig:rot_gradient} compares the rule of thumb to simulations with the \textit{coil simulation library} (see~\ref{ch:simulation} and~\ref{ch:coil_simulation_library}). The rule of thumb underestimates the gradient by about \SI{10}{\percent}.

\begin{figure}
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_gradient/rule_of_thumb_gradient_radius.pgf}}
        \end{pgfpicture}
        \caption{Dependency on the radius, with the coil distance fixed to the radius}
        \label{fig:rot_gradient_radius}
    \end{subfigure}
    \hspace{0.03\textwidth}
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_gradient/rule_of_thumb_gradient_current.pgf}}
        \end{pgfpicture}
        \caption{Dependency on the current}
        \label{fig:rot_gradient_current}
    \end{subfigure}

    \begin{subfigure}{\textwidth}
        \centering
        \begin{pgfpicture}
            \pgftext{\input{\imagepath/rule_of_thumb_gradient/rule_of_thumb_gradient_3d.pgf}}
        \end{pgfpicture}
        \caption{Gradient as a function of radius and current: Simulated gradients are displayed in red, the rule-of-thumb approximation in gray below.}
        \label{fig:rot_gradient_3d}
    \end{subfigure}
    \caption{Gradients around the center of a Helmholtz arrangement of coils with mutually invert currents for different radii and currents, comparing the rule of thumb \eqref{eq:rot_gradient} with simulated values. Parameters: $I = \SI{100}{\ampere}, r = \SI{10}{\centi\meter}, N_\text{windings} = 1$}
    \label{fig:rot_gradient}
\end{figure}
